class Solution {
public:
    int countSetBits(int num) {
        int count = 0;
        while (num > 0) {
            count += (num & 1);
            num >>= 1;
        }
        return count;
    }
    int maxPartitionsAfterOperations(string s, int k) {
        if (k == 26) return 1;

        int n = s.length();
        vector<int> leftMask(n);
        vector<int> leftDuplicate(n);
        vector<int> leftParts(n);

        int mask = 0;
        int duplicate = 0;
        int parts = 1;
        for (int i = 0; i < n; i++) {
            int bit = 1 << (s[i] - 'a');

            if ((mask & bit) != 0) {
                duplicate |= bit;
            }

            mask |= bit;
            if (countSetBits(mask) > k) {
                mask = bit;
                duplicate = 0;
                parts++;
            }

            leftMask[i] = mask;
            leftDuplicate[i] = duplicate;
            leftParts[i] = parts;
        }
        int result = parts;

        mask = 0;
        duplicate = 0;
        parts = 0;

        for (int i = n - 1; i >= 0; i--) {
            int bit = 1 << (s[i] - 'a');

            if ((mask & bit) != 0) {
                duplicate |= bit;
            }
            mask |= bit;

            int bitCount = countSetBits(mask);

            if (bitCount > k) {
                mask = bit;
                duplicate = 0;
                parts++;
                bitCount = 1;
            }
            if (bitCount == k) {
                if ((bit & duplicate) && (bit & leftDuplicate[i]) &&
                    (countSetBits(leftMask[i]) == k) &&
                    ((leftMask[i] | mask) != 0x3FFFFFF)) {
                    result = max(result, parts + leftParts[i] + 2);
                }
                else if (duplicate) {
                    result = max(result, parts + leftParts[i] + 1);
                }
            }
        }
        return result;
    }
};
